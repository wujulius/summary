# Redis

## Redis单线程的

## redis底层数据结构：

    redis的底层是hashtable（基于链表的数组）

## redis跳表（skiplist）

    链表插入元素很快，查询效率很慢，
    链表的每两个

    查询元素，可以跳跃一些元素
    当元素比较多时，使用跳表可以显著减少查找的次数

    有序链表改为可以进行折半查找的链表

## redis key过期还会读取到key值：、

    删除过期数据，redis提供了两种策略：
        1.惰性删除
        2.定期删除

## redis key没设置过期时间却被删除

## redis 的lfu和lru算法的区别：

    LRU算法(Least Recently Used，最近最少使用):淘汰很久没被访问过的数据，以最近一次访问时间作为参考（对于过期key使用该算法（常用算法））
    （常用淘汰策略）

    LFU算法(Least Frequently Used，最不经常使用):淘汰最近一段时间被访问次数最少的数据，以次数作为参考（对于热点缓存的数据使用该算法）

    绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点

## 删除redis的命令会阻塞吗

    如果删除大字符串类型，比如几个G，几百M。

    删除单个元素多的列表、集合、有序列表或者哈希表类型的Key

## redis的主从架构

## redis持久化

    默认选择RDB快照模式，所以redis并不是实时进行数据持久化，而是由一定的时间间隔，

## redis的RDB文件快照
    

    一、 对哪些数据做快照

    做的是全量快照（增量快照指的是第一次做全量快照，之后增量文件只记录每个时刻对数据的修改，会导致增量文件过大）

    二、 快照时会阻塞主线程吗

    利用写时复制技术（fork一个子进程进行快照，期间对于主线程中的数据的修改操作会先拷贝出该数据，然后再拷贝的数据上修改，保证快照截取的是一个时间点的数据），保证不影响主进程中的数据读写。

    fork操作会拷贝一份和主进程一模一样的子进程，但是它们拥有的内存空间独立，内存中的数据是一样的，两个进程可以各自独立地操作它们内存中的数据。

    利用写时复制技术子进程不影响主进程运行，但是fork进程时，主进程无法提供服务，并且子进程将数据写入磁盘需要时间，Redis为了避免多个fork子进程阻塞，只有等上一个fork的子进程完成了RDB操作后才能再次fork子进程进行RDB备份（同一时间只执行一个快照）。

    三、 多久执行一次RDB快照

    一般结合AOF和RDB使用，AOF作为两次RDB之间的增量文件，记录两次RDB期间发生的操作指令，第二次全量备份时在上一次全量备份的基础上执行AOF日志即可（会在AOF文件的开头写入上次快照完的位置），完成后将AOF文件清空，就不会导致AOF日志的增量信息过大。

## redis中save命令和bgsave命令的区别：
    
    手动进行持久化，可以使用save和bgsave命令

    SAVE

    基本命令：

    redis 127.0.0.1:6379> SAVE 
    OK
    该命令将在 redis 安装目录中创建dump.rdb文件。

    影响：

    SAVE 直接调用 rdbSave函数 ，阻塞 Redis 主进程，直到保存完成为止。在主进程阻塞期间，服务器不能处理客户端的任何请求。

    如果数据量小，用此命令可能感觉不出有什么区别，但是当数据量很大的时候，就需要谨慎使用这个命令。

    

    BGSAVE

    基本命令：

    127.0.0.1:6379> BGSAVE

    Background saving started
    客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功。

    影响：

    BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。

    bgsave为了保证快照的完整性，只能处理读操作，因此不能修改正在执行快照的数据

    BGSAVE方式比较适合线上的维护操作。

## redis之fork操作：

    1、fork操作
    （1）同步操作
        虽然fork同步操作是非常快的，但是如果需要同步的数据量过大，fork就会阻塞redis主进程。

    （2）与内存量息息相关
        内存越大，fork同步数据耗时越长，当然也跟服务器有关，服务器有物理机，也有虚拟机。

    （3）info:latest_fork_usec
        使用此命令可以查看持久化花费的时间，如果持久化时间过长，就会造成卡顿。

        例如：如果redis此时QPS上万，此时redis正在持久化，而且持久化时间比较长（1s或者10几秒），这个时候就会严重阻塞redis。

 

    2、改善fork
    （1）优先使用物理机或者高效的虚拟机支持fork操作

    （2）控制redis实际最大可用内存：maxmemory

    （3）合理配置linux内存分配策略：vm.overcommit_memory=1

    （4）降低fork频率：例如放宽AOF重写自动触发时机，减少不必要的全量复制。

## random key会造成死循环

    redis中有大量过期的key

    random key拿到过期的key然后把它删除，运气不行，由于找不到不过期的key就会造成死循环
    如果当前是master，执行randomkey命令时，redis会一直随机选择key，直到找到一个不过期的key，同时会把已经过期的key从整个实例中删除。

    也就是说，在这种场景下，虽然不会长时间阻塞整个实例，但也会比执行一个普通的命令耗时要久。如果你在一个大量已过期的实例上执行randomkey命令，那可能会导致业务访问redis变慢。

     如果当前是salve，执行randomkey命令时，redis会一直随机选择key，直到找到一个不过期的key


    解决方案就是增加一个最大重试次数，如果整个实例都是过期key，那么最多寻找maxtries次就返回，避免阻塞整个实例。

    注意点
    但要注意的是，如果达到了maxtries，那么返回的key是已经过期的key，你虽然在randomkey中看到了这个key，但对这个key执行其他命令时，还是拿不到这个key的。

    这个方案只针对slave上执行这个命令进行了修复，也就是不会再让redis陷入死循环。

    但在master上执行这个命令还是会发生上述的变慢问题，如果你在使用redis时，经常使用这个命令，同时实例中存在大量已经过期的key，那么redis变慢很有可能是这个问题导致的。
 
## redis的命令传播

 xfas 