# jvm动态扩展

    动态扩展，栈空间超出时，自动对栈空间进行扩容，来避免stack over flow的出现，JVM没有实现
    通过两种方式来实现：

        segmentedstack ：当栈空间不足时，创建一个新的栈通过链表的形式进行连接
        stackcopying：当栈空间不足时，会创建一个栈空间更大的栈将之前的栈中内容复制进去


    栈使用动态扩展实现

    堆由垃圾回收机制负责回收（又称GC堆）堆的优势是可以动态地分配内存大小，生存期也不用事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但它有缺点，由于要在运行时动态分配内存，存取速度会较慢。


## JVM虚拟机的三种编译方式：

### 前端编译

    将java文件编译成符合jvm规范的字节码（class）文件

    优点：

    a.这阶段的优化是指程序编码方面的；

    b.许多Java语法新特性('语法糖'：泛型、内部类等等)，是靠前端编译器实现的,而不是依赖虚拟机；

    c.编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度；

    缺点：

    1.对代码运行效率几乎没有任何优化措施；

    2.解释执行效率较低，所以需要结合下面的JIT编译；

    3.前端编译器：Oracle javac、Eclipse JDT中的增量式编译器(ECJ)等;







### AOT编译（预编译）

    3、静态提前编译(Ahead Of Time，AOT编译)

    程序运行前，直接把Java源码文件(.java)编译成本地机器码的过程；

    优点：

    a.编译不占用运行时间，可以做一些较耗时的优化，并可加快程序启动；

    b.把编译的本地机器码保存磁盘，不占用内存，并可多次使用；

    缺点：

    a.因为Java语言的动态性(如反射)带来了额外的复杂性，影响了静态编译代码的质量；

    b.一般静态编译不如JIT编译的质量，这种方式用得比较少；

    c.静态提前编译器(AOT编译器)：JAOTC、GCJ、Excelsior JET、ART (Android Runtime)等；

### JIT编译（即时编译）
    2、后端编译/即时(JIT)编译

    通过Java虚拟机(JVM)内置的即时编译器(Just In Time Compiler，JIT编译器)；在运行时把Class文件字节码编译成本地机器码的过程；

    优点：

    a.通过在运行时收集监控信息，把'热点代码'(Hot Spot Code)编译成与本地平台相关的机器码，并进行各种层次的优化；

    b.可以大大提高执行效率；

    缺点：

    a.收集监控信息影响程序运行；

    b.编译过程占用程序运行时间(如使得启动速度变慢)；

    c.编译机器码占用内存；

    d.JIT编译器：HotSpot虚拟机的C1、C2编译器等；

    另外，JIT编译速度及编译结果的优劣，是衡量一个JVM性能的很重要指标；所以对程序运行性能优化集中到这个阶段；也就是说可以对这个阶段进行JVM调优；

    4、前端编译 JIT编译

    到这里，我们知道目前Java体系中主要还是采用前端编译 JIT编译的方式，如JDK中的HotSpot虚拟机。

    前端编译 JIT编译方式的运作过程大体如下：

    1、首先通过前端编译把符合Java语言规范的程序代码转化为满足JVM规范所要求Class格式；

    2、然后程序启动时Class格式文件发挥作用，解释执行，省去编译时间，加快启动速度；

    3、针对Class解释执行效率低的问题，在运行中收集性能监控信息，得知'热点代码'；

    4、JIT逐渐发挥作用，把越来越多的热点代码'编译优化成本地代码，提高执行效率；

## 回收机制的触发时机

    monitor GC 与 Full GC
    Monitor GC触发机制：
    新生对象存在于Eden中，当Eden中内存不足时触发Monitor GC

    Full GC 触发机制：
    1.当老年代内存使用率达到阈值时
        1.1survivor区进行15次清理后的仍然存活的对象放到老年代
        1.2在执行monitor GC 时，先对survivor空间进行判断
            1.当survivor区的存储空间够用时，直接调用
            2.如果不够用，则检查老年代最大连续可用空间是否大于新生代的总和或者历次晋升到老年代的对象的平均大小
                如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。
                如果小于，则直接执行Full GC
    2.当调用system.gc()
    3.当元空间（meta space）达到指定参数时
    4.当jmap添加live参数时