- [java面试](#java面试)
  - [基础](#基础)
    - [1.JDK 和 JRE 还有jvm 有什么区别？](#1jdk-和-jre-还有jvm-有什么区别)
    - [2.跨平台特性定义和实现原理：](#2跨平台特性定义和实现原理)
    - [3.java语言的特点是：](#3java语言的特点是)
    - [4.什么是字节码？字节码的好处：](#4什么是字节码字节码的好处)
  - [集合接口](#集合接口)
    - [1.迭代器是什么：](#1迭代器是什么)
    - [2.迭代器如何使用：以及其特点：](#2迭代器如何使用以及其特点)
    - [iterator 和 listiterator的区别：](#iterator-和-listiterator的区别)
    - [3.遍历一个list的方法有？](#3遍历一个list的方法有)
    - [4.arraylist的优缺点：](#4arraylist的优缺点)
    - [5.实现randomaccess接口](#5实现randomaccess接口)
    - [6.arraylist和array进行相互转化](#6arraylist和array进行相互转化)
    - [7.arraylist和linkedlist的区别：](#7arraylist和linkedlist的区别)
    - [8.arraylist和vector的区别](#8arraylist和vector的区别)
    - [9.插入数据时arraylist，linkedlist和vector插入谁的速度更快：](#9插入数据时arraylistlinkedlist和vector插入谁的速度更快)
    - [10.多线程场景下如何使用arraylist](#10多线程场景下如何使用arraylist)
    - [11.list和set的区别：](#11list和set的区别)
    - [12.hashset的实现原理](#12hashset的实现原理)
    - [13.hashset是如何检查重复和保证唯一](#13hashset是如何检查重复和保证唯一)
    - [14.hashcode和equals方法的相关规定：](#14hashcode和equals方法的相关规定)
    - [15.==和equals方法的区别](#15和equals方法的区别)
  - [Map接口](#map接口)
    - [1.hashmap的实现原理：](#1hashmap的实现原理)
    - [2.hashtable和hashmap以及treemap的区别：](#2hashtable和hashmap以及treemap的区别)
    - [3.hashmap的数据结构：](#3hashmap的数据结构)
    - [4.hashmap的扩容因子：](#4hashmap的扩容因子)
    - [拉链法和红黑树](#拉链法和红黑树)
    - [转化为红黑树的目的：](#转化为红黑树的目的)
    - [hashmap有哪些方法来降低hash冲突](#hashmap有哪些方法来降低hash冲突)
    - [5.多线程下使用hashmap](#5多线程下使用hashmap)
    - [6.hashmap的put方法的具体流程：](#6hashmap的put方法的具体流程)
    - [7.classloader和class.forname的区别：](#7classloader和classforname的区别)
    - [8.treeset和treemap的关系：](#8treeset和treemap的关系)
    - [treemap](#treemap)
    - [hashtable](#hashtable)
    - [linkedhashmap](#linkedhashmap)
  - [流、](#流)
    - [1.流的概念：](#1流的概念)
    - [2.流的分类：](#2流的分类)
    - [3.io模型：](#3io模型)
    - [4.同步和异步的区别：](#4同步和异步的区别)
    - [5.阻塞和非阻塞区别：](#5阻塞和非阻塞区别)
    - [6.io多路复用方案：](#6io多路复用方案)
    - [7.两种模式的区别](#7两种模式的区别)
    - [8.String 编码 utf-8和GBK的区别](#8string-编码-utf-8和gbk的区别)
    - [9.什么时候使用字节流，（字符流）二者的区别是：](#9什么时候使用字节流字符流二者的区别是)
  - [类加载器](#类加载器)
    - [1.为什么需要自定义类加载器](#1为什么需要自定义类加载器)
    - [2.双亲委派模型](#2双亲委派模型)
    - [3.双亲委派机制的好处](#3双亲委派机制的好处)
    - [4.如何自定义类加载器](#4如何自定义类加载器)
    - [5.面向对象和面向过程的区别](#5面向对象和面向过程的区别)
    - [6.java源代码到运行的三个步骤](#6java源代码到运行的三个步骤)
    - [7.java是如何进行即时编译的，好处是](#7java是如何进行即时编译的好处是)
    - [8.jvm编译字节码的三种方式](#8jvm编译字节码的三种方式)
    - [9.混合模式是如何执行的](#9混合模式是如何执行的)
  - [](#)
    - [1.java应用程序和小程序的区别](#1java应用程序和小程序的区别)
    - [2.String字符常量和Char字符常量的区别](#2string字符常量和char字符常量的区别)
    - [3.构造器是否可以被重写](#3构造器是否可以被重写)
    - [4.java三大特性的含义：](#4java三大特性的含义)
    - [5.String Stringbuffer Stringbuilder区别](#5string-stringbuffer-stringbuilder区别)
    - [6.使用final修饰 char value[]的好处](#6使用final修饰-char-value的好处)
    - [7.自动装箱和自动拆箱](#7自动装箱和自动拆箱)
    - [8.在一个静态方法中调用非静态方法或成员为什么时非法的](#8在一个静态方法中调用非静态方法或成员为什么时非法的)
    - [9.在java中定义无参构造方法的作用是](#9在java中定义无参构造方法的作用是)
    - [10.接口和抽象类的区别](#10接口和抽象类的区别)
    - [11.成员变量和局部变量的区别](#11成员变量和局部变量的区别)
    - [12.在调用子类构造方法之前先调用父类的无参构造方法的目的：](#12在调用子类构造方法之前先调用父类的无参构造方法的目的)
    - [13.一个类的构造方法的作用是什么：一个类的没有书写构造方法能正常执行吗](#13一个类的构造方法的作用是什么一个类的没有书写构造方法能正常执行吗)
    - [14.对象引用相等和对象相等的区别](#14对象引用相等和对象相等的区别)
    - [15.== 和equals方法的区别](#15-和equals方法的区别)
    - [16.hashcode和equals](#16hashcode和equals)
    - [17.final关键字的总结](#17final关键字的总结)
    - [java序列化时有些属性不想进行序列化，用什么修饰](#java序列化时有些属性不想进行序列化用什么修饰)
  - [java异常常见面试题：](#java异常常见面试题)
    - [error和exception的区别：](#error和exception的区别)
    - [运行时异常和受检异常的区别：](#运行时异常和受检异常的区别)
    - [jvm是如何处理异常的：](#jvm是如何处理异常的)
    - [java常见运行异常有哪些](#java常见运行异常有哪些)
  - [多线程](#多线程)
    - [线程，进程以及程序的概念](#线程进程以及程序的概念)
    - [如何理解内存泄露问题，如何避免内存泄露问题，哪些情况导致内存泄露的关系，如何解决：](#如何理解内存泄露问题如何避免内存泄露问题哪些情况导致内存泄露的关系如何解决)
    - [为什么内存泄露会发生](#为什么内存泄露会发生)
    - [怎样阻止内存泄露](#怎样阻止内存泄露)
    - [线程池的原理](#线程池的原理)
    - [为什么使用线程池](#为什么使用线程池)
    - [线程池的优点：](#线程池的优点)
    - [线程池的创建：](#线程池的创建)
    - [线程池大小分配](#线程池大小分配)
    - [rejectedexecutionhandler 饱和策略](#rejectedexecutionhandler-饱和策略)
    - [策略配置方法（两种）](#策略配置方法两种)
    - [excutor的两级调度模型](#excutor的两级调度模型)
    - [executor](#executor)
    - [线程安全和线程不安全的区别](#线程安全和线程不安全的区别)
    - [实现线程安全的方式](#实现线程安全的方式)
      - [互斥同步锁（悲观锁）](#互斥同步锁悲观锁)
      - [非阻塞同步锁（乐观锁）](#非阻塞同步锁乐观锁)
        - [cas算法](#cas算法)
      - [无同步方案](#无同步方案)
    - [乐观锁和悲观锁的概念](#乐观锁和悲观锁的概念)
    - [volatile关键字的作用：](#volatile关键字的作用)
    - [threadloacl原理：](#threadloacl原理)
    - [volatile的场景：](#volatile的场景)
    - [volatile变量和synchronized的区别](#volatile变量和synchronized的区别)
#  java面试
## 基础

### 1.JDK 和 JRE 还有jvm 有什么区别？

### 2.跨平台特性定义和实现原理：

### 3.java语言的特点是：

### 4.什么是字节码？字节码的好处：

    java源代码 jvm 
    1.可以解决传统解释型语言执行效率低的问题
    2.保留了解释型语言可移植性，
    字节码文件一旦生产便可再不同计算机运行


## 集合接口

### 1.迭代器是什么：
    迭代器是用来遍历集合的接口 
    代替了原来的enumeration，可以用来在迭代过程中进行删除

### 2.迭代器如何使用：以及其特点：
    迭代器的特点：
        迭代器使用单向遍历，更安全，当发生修改时报concurrentmodificationexception

### iterator 和 listiterator的区别：
    单向遍历    双向遍历
                多了添加替换以及获取前面元素的索引和后面元素的索引位置
    遍历set和list  只能遍历list
### 3.遍历一个list的方法有？

    1.for循环
    2.iterator遍历
    3.foreach遍历（本质上使用iterator遍历）不用显式声明迭代器，代码简单，不易出错，不能使用迭代器方法对元素进行相应的操作

### 4.arraylist的优缺点：
    顺序添加快
    底层使用数组实现了rendomaccess接口,查找速度快

    缺点:添加删除一个元素时，需要进行整体复制，耗时长

### 5.实现randomaccess接口
    实现randomaccess接口，查找元素的平均时间复杂读为1

### 6.arraylist和array进行相互转化
    array.aslist
    arraylist.toarry()

### 7.arraylist和linkedlist的区别：
    随机访问：arraylist随机访问要快
    存取效率：不涉及首尾的插入和删除，linkedlist的效率高
    实现方式：arraylist     动态数组  linkedlist     双向链表
    内存占用：linkedelist更占内存，除了存储数据外还存储两个引用（直接前继和直接后继），一个指向前面元素，一个
    二者都没加同步锁，都是线程不安全的，

### 8.arraylist和vector的区别
    
    二者都实现了list接口
    线程安全vector是线程安全的
        vector所有方法都添加了同步锁，  
    性能上： 前者由于后者，后者加了同步锁在同步操作上会耗费大量时间
    扩容上：arraylist扩容为原来的1.5倍，vector扩容为原来的2倍

### 9.插入数据时arraylist，linkedlist和vector插入谁的速度更快：
    arraylist和vector底层使用的都是数组
    而vector由于使用了同步锁，在同步操作上会耗费大量时间

    linkedlist插入数据只需要知道当前项前后元素即可进行插入元素
    而数组插入元素需要根据索引插入后，将后面的元素依次移位，耗时长

### 10.多线程场景下如何使用arraylist
    通过collections.synchronizedlist实现

### 11.list和set的区别：
    list 有序 可重复 可以插入多个null
    set 无需 不可重复 只可以插入一个null

    list可以使用 for 循环    set不能 
        因为set是无序的，（存放顺序和取得顺序不一致）
    
    list查找效率高
    set插入删除效率高

    实现类 list arraylist vector linkedlist
        set hashset linkedhashset treeset

### 12.hashset的实现原理
    基于hashmap实现，hashset的值存在hashmap的key中，hashmap的value值存present
    对hashset的操作，一般直接调用底层hashmap的方法

### 13.hashset是如何检查重复和保证唯一

    hashset的add方法会调用hashmap的put方法，通过判断key的hash值以及equals方法来判断是否重复
    若key已经存在hashmap会用新v代替旧v

### 14.hashcode和equals方法的相关规定：
    两个对象相等那么两个对象的hashcode也一定相等
    两个对象相等，equals一定返回true
    hashcode相等equals方法的返回值不一定为true

### 15.==和equals方法的区别

    ==用来判断两个变量或实例是否指向一个内存空间，（指引用是否相同）
    equals用来判断  内存空间的值是否相同，（指的是值是否相同）

## Map接口

### 1.hashmap的实现原理：
    hashmap方法基于hash算法来实现：
        首先再插入一个元素时，先计算对象的key的hashcode hash出 当前对象的数组下标，
        存取时：
            若hash值相同，对key值进行判断，
            若key值相同，覆盖掉原来的值
            若key值不相同，将冲突的对象放到链表中
        获取时：由计算出的相应的hash值查找对应的下标，再判断key值是否相同，同取出相应的值

### 2.hashtable和hashmap以及treemap的区别：
    hashtable是线程安全的
    遍历 hashtable通过enumeration  hashmap iterator
    hashtable 不允许用空键值对    hashmap允许一个键值为null
    hashtable  默认大小为11  的扩容机制为： 2*old+1
    hashmap 默认大小为16  扩容机制为原来的2的指数次倍
    treemap保存记录根据键值进行排序，默认升序

### 3.hashmap的数据结构：
    1.8之前数组+链表
    

### 4.hashmap的扩容因子：

    0.75 当达到扩容因子，会将数组扩容为原来的1倍

### 拉链法和红黑树

    拉链法：java1.8之前，当遇到hash冲突时，将冲突值存入到链表种

    红黑树法：java1.8之后，当遇到hash冲突时，现将冲突值存入到链表中，当链表长度达到阈值时将链表转化为红黑树

### 转化为红黑树的目的：

    防止链表过长，造成查询效率降低

### hashmap有哪些方法来降低hash冲突
    1.链地址法：将hash冲突的值存到链表中
    2.hash法：通过两次扰动降低hash冲突的概率
    3.使用红黑树降低时间复杂度，提高查询效率
### 5.多线程下使用hashmap

    调用collections.synchronizedmap方法实现，使用的** 互斥锁 **，只允许一个线程访问，效率低

### 6.hashmap的put方法的具体流程：
    首先根据key的hash值，（调用hash方法）（hash方法：将取得的hashcode的值的高16bit和低16bit进行异或减少碰撞概率，得到hash值）
    使用hash值和hashmap的数组长度-1进行相与得到下标值

### 7.classloader和class.forname的区别：
    classloader 只干一件事，将class文件加载到jvm中不会加载static代码块
    class.forname 将class文件加载到jvm中，还会对类进行解释，可控制是否加载类中的static代码块
### 8.treeset和treemap的关系：
    treeset底层使用的容器为treemap，和hashset类似，在对treeset进行操作时，是调用treemap的方法进行操作
    treemap底层使用红黑树的排序二叉树，
### treemap
    使用的数据结构为红黑树的排序二叉树，按照键值进行排序，默认按照升序排序，
    实现了sortedmap接口，当使用红黑树进行排序时，必须实现comparable接口，或者引入自定义的
    comparator类，否则会报classcastexception
### hashtable

    hashtable常用方法和hashmap类似，其在任一时间只能有一个线程访问，是线程安全的
    但其并发性又不如concurrentmap，后者使用了分段锁
    因而在使用线程安全时使用con      不需线程安全时用hashmap

### linkedhashmap

    记录了插入顺序

## 流、

### 1.流的概念：
    流有输入和输出，输出是指从程序到数据源，输入是指从数据源到程序

### 2.流的分类：
    按数据流的方向分为输入流和输出流
    按使用方式：字节流和字符流
    按找处理流的方式：节点流和处理流
    节点流对特定设备进行读写数据的流，
    处理流对已经存在的流进行封装，然后通过封装后的流进行数据的读写操作

### 3.io模型：
    按网络编程分类：非阻塞io，阻塞io，信号驱动io，多路复用io，异步io

    按posix分类：异步io和同步io

    一个io操作分为两步io请求和实际io操作

    区别在于第二步时，实际io操作时，会不会将请求进程阻塞，会同步
        不会异步

### 4.同步和异步的区别：
    二者关注的是信号通信机制，在调用一个进程后，是否会立即返回一个返回值，还是等待这个返回值，等待为同步，立即返回为异步

### 5.阻塞和非阻塞区别：
    二者关注的是程序在等待方法返回值的状态，若在等待期间将线程挂起一直等待返回值即为阻塞，而非阻塞不会挂起，

### 6.io多路复用方案：
    多路复用依赖于：事件多路分离器，和事件处理器
    事件分离器负责将事件源的相应io事件分发到事件处理器进行处理

    与之相关的两个模式：reactor和preactor
    前者同步，后者异步

### 7.两种模式的区别

    相同点：都是对某个事件的通知
        demuliplextor负责查看事件提交io操作（异步），查看是否可以进行操作（同步），满足条件调用handler，
        不同点：当调用handler时，异步已经完成io操作，同步表示可以进行某个操作

### 8.String 编码 utf-8和GBK的区别

    GBK是中文编码，（支持中文简体和中文繁体）
    utf-8支持所有国家的语言：
    GBK占用空间比utf-8空间要小

### 9.什么时候使用字节流，（字符流）二者的区别是：

    字节流操作的是一个字节，
    字符流操作的是两个字节（unicode），主要来处理字符或字符串
    字符流是jvm将字节转换为两个字节的unicode字符为单位的字符

    关系到中文的使用字符流比较好

    主要区别：
        字节流在操作是不需要缓存,直接对文本进行操作
        字符流在通过缓冲区操作字符

    文本内容（图片等）存在硬盘，字符值在内存中才会形成

## 类加载器

### 1.为什么需要自定义类加载器

    1.加密：对字节码文件加密预防反编译，其中使用了某种特定的算法，因而不能使用原生的类加载器，需要自定义classloader进行解密，在进行加载

    2.从非标准的来源加载字节码

### 2.双亲委派模型

    当一个字节码文件进行加载时首先询问当前类加载器是否已经加载了该类，直接返回已加载的类，
    若没有，则将字节码委派给父类加载器，执行同样的机制，还没有委派给父类的父类的加载器，直到
    到达启动类加载器，若还没有报classnotfoundexception然后调用findclass方法进行查找


### 3.双亲委派机制的好处

    安全性：防止自定义的类动态替换java原生的核心类

    防止重复加载，因为jvm区分不同的类，不仅仅是根据类名，若该类被两个不同的加载器加载就是不同的类

### 4.如何自定义类加载器

    首先继承classloader  然后重写findclass（）方法
     defaultfindclass 方法可以将二进制流文件转化为符合jvm规范的字节码文件（java.lang.class）

### 5.面向对象和面向过程的区别

    面向过程的性能要优于面向过程，因为面向对象要进行类的实例化，开销大，
        缺点没有面向对象易扩展，易复用，易维护

    面向对象：易扩展，易复用，易维护  
    因为具有封装继承多态的特点可以开发出低耦合的系统，系统更加灵活

### 6.java源代码到运行的三个步骤

    首先使用java源码级编译器将对应的java源文件（.java）进行编译，编译成相应的字节码文件，
    将字节码文件给到对应系统的虚拟机，将字节码文件转换成相应系统平台的机器码文件，进行运行

### 7.java是如何进行即时编译的，好处是

    
    将字节码文件，传入到jvm中，使用jit（运行时编译）
    当java源代码进入后，jit对其进行编译，完成第一次编译后，将其编译所得的机器码文件存存储，下次直接使用

    java即时编译的好处：提高代码运行效率

    在程序响应时间下，没有达到最大的优化，占用存储空间

### 8.jvm编译字节码的三种方式

    解释器模式，jit即时编译器模式，混合模式


### 9.混合模式是如何执行的

    以hotspot为例，该jvm采用混合模式，先解释执行字节码文件，然后使用惰性评估，评估哪些代码是热点代码，jit对这部分代码进行即时编译，

## 

### 1.java应用程序和小程序的区别

    应用程序通过主线程（主方法main）来执行
    applet小程序没有main方法，通过init（）和run方法嵌在浏览器上运行

### 2.String字符常量和Char字符常量的区别
    
    形式上:
    char常量在定义时使用’‘来定义
    String        “”
    占内存的大小：
        字符常量占两个字节
        字符串 占若干个字节（至少为一个字节）
    含义上：
        字符常量相当于一个整型常量，可以用ascII表示，可以进行运算
        字符串常量存储的是一个地址值    字符串常量的存储地址

### 3.构造器是否可以被重写

    不能被重写，因为子类不能继承父类的私有属性和构造方法，但是可以被重载

### 4.java三大特性的含义：

    封装：定义私有属性，提供公共方法来进行访问
    继承：子类可以在父类的基础上添加新的功能和数据
    多态：在编程时并不知到对象引用指向对象的具体类型，引用调用哪些方法，只有在运行时才知道

### 5.String Stringbuffer Stringbuilder区别

    String中使用final修饰字符数组来保存字符串
    Stringbuffer和Stringbuilder使用final来修饰类
   
    线程安全：

    Stringbuffer使用同步锁对其进行加锁，因而其是线程安全的
    string使用final修饰所以是线程安全的

    操作上：
        每次在string进行操作时，都会创建一个新对象，然后将指针指向新的string对象
        对stringbuffer进行操作时，都是直接操作原有对象，
    
    使用上：
        在操作少量数据时，使用String
        在单线程条件下，操作大量数据，stringbuilder
        多                          Stringbuffer

### 6.使用final修饰 char value[]的好处

    使用final修饰使其变成不可变对象

    保证安全性：
        String类型是java中最常用的类型之一，常常存储敏感信息，保证其不可变可以防止因为值改变所带来的不安全问题
    线程安全：
        同时多个线程尝试修改该String时会创建一个新的String，因而不存在线程安全问题
    节省空间：
        不可变对象存在常量池中，当添加相同值时，若该常量池中已经存在直接引用指向该对象节省空间

    性能上：

### 7.自动装箱和自动拆箱
    
    概念：
        将对应的基本类型包装为其引用类型
        将包装类型转化成基本类型

    Integer自动装箱池的范围是-128~127

    Byte,Short,Long范围是-128~127

    Character范围是0~127

    Float和Double没有自动装箱池

### 8.在一个静态方法中调用非静态方法或成员为什么时非法的

    在类加载时，优先加载静态方法，而非静态成员还未加载，找不到的话，会产生错误

### 9.在java中定义无参构造方法的作用是

    当一个子类继承该类时，在执行子类构造方法时，会先执行父类的构造方法，若子类没有使用super（）方法调用父类的构造方法，则会调用父类的无参构造方法，若父类没有无参数构造方法，会造成编译错误

### 10.接口和抽象类的区别

### 11.成员变量和局部变量的区别

### 12.在调用子类构造方法之前先调用父类的无参构造方法的目的：
    
    帮助子类初始化

### 13.一个类的构造方法的作用是什么：一个类的没有书写构造方法能正常执行吗

    构造方法的作用：用于完成类对象的初始化

    能  有默认的无参构造方法

### 14.对象引用相等和对象相等的区别

    前   内存地址相同
    后   内存存储的内容相同

### 15.== 和equals方法的区别

    == 比较的 二者的内存对象的地址是否相同
    equals 重写方法  比较的是二者的内容
            未     和==一样效果

### 16.hashcode和equals

### 17.final关键字的总结

    类  该类不能被继承，其中的方法都被隐式修饰final

    变量 基本数据类型   一旦初始化数值无法改变
         引用数据类型   引用无法改变，但其中的内容可以改变，初始化之后不能指向其他对象 

    方法：进行方法锁定，防止子类修改
        提高效率
            private修饰的方法 隐式使用final修饰方法

### java序列化时有些属性不想进行序列化，用什么修饰

    用transient修饰，
    用transient修饰的字段可以阻止其序列化
    transient修饰的字段在反序列化时，无法进行持久化和恢复，
    transient只能修饰变量不能修饰类和方法

## java异常常见面试题：
### error和exception的区别：
    error是虚拟机相关错误：可能原因有：内存溢出，
    error错误应用程序无法进行捕获处理，一旦发生通常应用程序会停止运行，无法通过应用程序进行恢复

### 运行时异常和受检异常的区别：
    前者java编译器不会对其进行检查只能在运行时发现
    后者Java编译器会对其进行检查，在编译时即可发现，而且必须对其进行处理
### jvm是如何处理异常的：
    当一个方法发生异常时，会首先创建一个异常对象并转交给虚拟机（里面有异常名称，异常描述，异常时应用程序的状态）抛出异常，jvm寻找是否有处理该异常的代码，有交给它，没有调用默认的异常处理器进行处理，默认异常处理器打印异常信息，终止应用程序。

### java常见运行异常有哪些
    
    indexoutofboundsexception
    arraystoreexception
    nullpointerexception
    classcastexception
## 多线程

### 线程，进程以及程序的概念

    线程是轻量级进程，是一个比进程更小的执行单位，一个进程可以产生多个线程，同类线程之间共享资源空间，
    进程是系统运行的基本单位，程序一次执行的过程
    程序是指存储在磁盘中含指令和数据的文件，即静态代码

### 如何理解内存泄露问题，如何避免内存泄露问题，哪些情况导致内存泄露的关系，如何解决：

    内存泄露问题：当内存中出现一些不被使用的对象时，jvm无法对其进行回收

### 为什么内存泄露会发生
    
    当一个对象比另一个对象生命周期长时，生命周期的对象已经不被程序使用，而生命周期长的对象还在使用，导致其无法被虚拟机回收，当这个生命周期长的对象引用多个这样的对象，这是就可能会发生内存不足的情况出现。同时，相应被引用对象还引用着大量对象，导致这些对象也不能被回收，这是就造成了大量内存资源的浪费
### 怎样阻止内存泄露

    1.在使用list和map集合以及大对象之后将其赋值为null
    2.避免使用substring方法，会导致内存泄露
    3.避免一些死循环重复创建对象或对集合添加元素撑爆内存
    4.简洁数据结构，少用静态集合
    5.即时关闭打开的文件，以及socket句柄
    6.关注监听器（listener）和回调（callbacks），当监听器不在被使用时，及时注销

### 线程池的原理

### 为什么使用线程池

    线程是稀有资源，使用线程池，可以减少线程创建和销毁的次数，使线程可以重复使用
    线程池可以根据系统的负载能力，调整线程池中工作线程的数量，从而防止服务器崩溃
### 线程池的优点：
    
    降低资源的消耗：减少线程创建和销毁的次数
    提高线程的可管理性：使用线程池可以对线程进行统一管理以及监控和调优
    提高响应速度：当任务到达时，任务可以不需要等待线程的创建直接执行
### 线程池的创建：


    几个重要参数：
        核心线程池中线程的数量
        线程池中线程最大数量
        当活跃线程超过核心线程时，空闲多余线程最大存活时间
        存活时间的单位
        存放任务的队列
        当线程池数量和任务队列已满时的处理策略

### 线程池大小分配
    分配判断依据：任务类型，cpu密集型，混合型，io密集型
    cpu密集型
    使用较小的线程池    一般线程池大小设置为cpu核心数+1

    io密集型
    使较大的线程池        方式一：cpu核心数*2
                        方式二：（线程等待时间/cpu时间之比+1）*cpu数目
                        线程等待时间越长，所需线程越多，cpu时间越长，所需线程越少
    混合型，分为前两者，依据不同的任务类型使用相应的线程池，



### rejectedexecutionhandler 饱和策略

    java提供了四种饱和策略：
        默认为abortpolicy   不处理直接抛出异常
        callerrunspolicy  调用所在线程处理任务 
        discardoldestpolicy 丢弃队列的最近一个任务，执行该任务
        discardpolicy   不处理直接丢弃

### 策略配置方法（两种）

    位置不同：相对于threadpoolexecutor

### excutor的两级调度模型

    上层：java程序将应用分解为多个任务，使用executor将任务映射成为固定数量的线程
    底层：操作系统内核将线程映射到硬件处理器上

### executor

    定义的java线程既是工作单元，又是执行机制
    在executor种将工作单元和执行机制分离开来，
    runable和callable是工作单元，executor来提供执行机制

    executor基于生产者消费者模式，工作单元提交任务的操作相当于生产者，executor执行任务的操作相当于消费者
### 线程安全和线程不安全的区别

    线程安全：线程执行过程中不会产生线程共享资源的冲突
    线程不安全：多个线程操作数据可能造成

### 实现线程安全的方式 

    1.互斥同步
        互斥量
        信号量
        临界区
    2.非阻塞同步
    3.无同步方案

####  互斥同步锁（悲观锁）

    特征：互斥 ：非你即我 
        同步：顺序访问
        java里的互斥同步锁： synchronized和reentrantlock

        互斥同步锁都是可重入锁 好处是：不会产生死锁问题，
                            缺点是：涉及到核心态和用户态的切换，消耗性能

        可重入锁优化机制：自旋锁，适应性自旋锁，轻量级锁，锁粗化和锁消除
#### 非阻塞同步锁（乐观锁）

    采用cas算法实现
    不可重入锁否则会造成死锁
##### cas算法

    CAS全称为compare and swap 是并发编程常用的算法
        可以用来实现无锁式同步机制
        CAS一共有三个值：V（实际读取位置的值），A（旧的预期值），B（线程方法的执行结果（新值））
        主要用途是用来使用不加锁的方式来实现同步
            可以满足多个线程访问同一个资源
        当一个线程访问一个位置的资源时，访问它的数据并执行自己的方法，在执行完方法后，将之前获取到的数据值和如今位置的数值进行比较，相同证明当前没有其他线程更新过该数据，将返回值写入到该位置，若不相同则证明有其他线程访问该线程，则将如今的数据取出执行上一个操作，一直循环直到数值相同为止
    
    CAS指令执行时，当且仅当V的值等于预期值A时，才会将V的值设为B，如果V和A不同，说明可能是其他线程做了更新，那么当前线程就什么都不做，最后，CAS返回的是V的真实值。
    而在多线程的情况下，当多个线程同时使用CAS操作一个变量时，只有一个会成功并更新值，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试。
    
    正是基于这样的原理，CAS即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。
    
    CAS的应用类
        Java中提供了一系列应用CAS操作的类，这些类位于java.util.concurrent.atomic包下，其中最常用的就是AtomicInteger，该类可以看做是实现了CAS操作的Integer

    可能会出现ABA问题：
        其他线程修改数次之后的值和原来的值相同
    解决方案：
        添加版本号以予以区分
#### 无同步方案

    1.可重入代码
        任何时候都能进行中断重入操作，特点是不会依赖堆上共享的资源
    2.threadpool和volatile
        每个线程对数据进行操作时，首先从共享资源拷贝一份到内存中，单独对其进行操作
    3.线程本地存储
        一个共享资源一定要被多个线程访问，可以尽量先让一个线程完成所有操作
        例子为请求应答型web服务器

### 乐观锁和悲观锁的概念

    乐观锁：乐观锁认为，读多写少，并发的可能性比较低，
        使用乐观锁，在进行更新操作时，会先判断一下在此期间有没有更新数据
        先读取当前版本号，在加锁（将当前版本号和上次更新版本号进行比较，一样更新）
        如果不一样，更新失败，重复读比较写的操作

    悲观锁：悲观锁认为，写操作比较多，并发可能性比较大，每当一个线程操作数据时，给其加锁，其他想要操作数据的线程阻塞，直到获取到锁

### volatile关键字的作用：
    可见性：当一个线程对共享变量进行写操作时，会立即将数据存入到内存中，当其他线程访问时会读取新值
    有序性：jvm向处理器发送一个lock前缀指令，将这个变量所在缓存行的数据写入内存中

        lock前缀指令会相当于一个内存屏障（内存栅栏），会保证在其之前的指令执行完成，后面的指令在进行重排序后不会排到内存屏障之前的位置

### threadloacl原理：
    threadlocal用来维护本线程的变量，
    threadlocal是将各线程变量的值存入到map中，存入时以值为map的value以当前threadlocal本身为key
    需要用时获取的是线程之前存入的值
    当存入的值为共享变量的值时，获取的也是共享变量的值，存在并发问题

### volatile的场景：
    1.状态转换
        仅仅使用boelean值来指示发生了一个一次性的重要时间，例如初始化和关机，通常只有一个状态转换
    2.一次性安全发布

    3.独立观察
        主要作用是定期观察发布结果供应用程序内部使用
        一个线程对某个值每隔几秒进行读取，并更新相应的volatile变量以供其他线程进行访问
    4.volatilebean模式
        放入这个模式中的类型必须是线程安全的
        在这个模式中的所有变量必须是用volatile修饰的，并且其中的getter和setter方法必须是非常普通的，不能有任何约束
    5.开销较低的读写策略
        当读操作大于写操作时，使用synchronized（内部锁）和volatile变量结合，来减少公共代码路径的开销
        使用volatile来定义变量，使用内部锁来保证写操作是原子的，
        而读操作不加锁，可以来减少开销，优于无竞争锁获取的开销

### volatile变量和synchronized的区别

    volatile变量具有可见性，但是不具备synchronized的原子性
    可以用于线程安全：
    条件是：多个变量或一个变量修改后的值和之前的值之间不存在约束

    变量没有包含在其他变量的不变式中
    变量的写操作不依赖于当前值



