- [数据库面试](#数据库面试)
  - [基础知识](#基础知识)
    - [数据保存在内存](#数据保存在内存)
    - [数据保存在文件](#数据保存在文件)
    - [数据保存在数据库](#数据保存在数据库)
    - [什么是SQL？](#什么是sql)
    - [什么是MySQL?](#什么是mysql)
    - [数据库三大范式是什么](#数据库三大范式是什么)
    - [mysql有关权限的表都有哪几个](#mysql有关权限的表都有哪几个)
    - [MySQL的binlog有有几种录入格式？分别有什么区别？](#mysql的binlog有有几种录入格式分别有什么区别)
    - [数据库类型](#数据库类型)
    - [MySQL存储引擎MyISAM与InnoDB区别](#mysql存储引擎myisam与innodb区别)
    - [存储引擎](#存储引擎)
    - [常用数据库引擎](#常用数据库引擎)
    - [MyISAM索引与InnoDB索引的区别？](#myisam索引与innodb索引的区别)
    - [聚簇索引和非聚簇索引](#聚簇索引和非聚簇索引)
    - [InnoDB引擎的4大特性](#innodb引擎的4大特性)
    - [引擎的选择](#引擎的选择)
    - [索引](#索引)
    - [什么是索引？](#什么是索引)
    - [索引的优缺点](#索引的优缺点)
    - [索引有哪几种类型？](#索引有哪几种类型)
    - [索引的数据结构（b树，hash）](#索引的数据结构b树hash)
    - [查询方式：](#查询方式)
    - [B+tree性质：](#btree性质)
    - [hash索引](#hash索引)
    - [索引的基本原理](#索引的基本原理)
    - [两种索引算法的区别：](#两种索引算法的区别)
    - [创建索引的原则](#创建索引的原则)
    - [创建索引的三种方式](#创建索引的三种方式)
    - [使用索引查询一定能提高查询的性能吗？为什么](#使用索引查询一定能提高查询的性能吗为什么)
    - [索引范围查询(INDEXRANGESCAN)适用于两种情况:](#索引范围查询indexrangescan适用于两种情况)
    - [百万级别或以上的数据如何删除](#百万级别或以上的数据如何删除)
    - [前缀索引](#前缀索引)
    - [什么是最左前缀原则？什么是最左匹配原则](#什么是最左前缀原则什么是最左匹配原则)
    - [B树和B+树的区别](#b树和b树的区别)
    - [使用B树的好处](#使用b树的好处)
    - [使用B+树的好处](#使用b树的好处-1)
    - [hash索引和B+树有什么区别或者说优劣呢](#hash索引和b树有什么区别或者说优劣呢)
    - [B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据](#b树在满足聚簇索引和覆盖索引的时候不需要回表查询数据)
    - [辅助索引](#辅助索引)
    - [何时使用聚簇索引与非聚簇索引](#何时使用聚簇索引与非聚簇索引)
    - [非聚簇索引一定会回表查询吗？](#非聚簇索引一定会回表查询吗)
    - [联合索引是什么？为什么需要注意联合索引中的顺序？](#联合索引是什么为什么需要注意联合索引中的顺序)
    - [数据库事务](#数据库事务)
    - [事物的四大特性(ACID)介绍一下?](#事物的四大特性acid介绍一下)
    - [什么是脏读？幻读？不可重复读？](#什么是脏读幻读不可重复读)
    - [什么是事务的隔离级别？MySQL的默认隔离级别是什么？](#什么是事务的隔离级别mysql的默认隔离级别是什么)
    - [隔离级别与锁的关系](#隔离级别与锁的关系)
    - [按照锁的粒度分数据库锁有哪些？](#按照锁的粒度分数据库锁有哪些)
    - [MyISAM和InnoDB存储引擎使用的锁：](#myisam和innodb存储引擎使用的锁)
    - [行级锁，表级锁和页级锁对比](#行级锁表级锁和页级锁对比)
    - [MySQL中InnoDB引擎的行锁是怎么实现的？](#mysql中innodb引擎的行锁是怎么实现的)
    - [InnoDB存储引擎的锁的算法有三种](#innodb存储引擎的锁的算法有三种)
    - [什么是死锁？怎么解决？](#什么是死锁怎么解决)
    - [为什么要使用视图？什么是视图？](#为什么要使用视图什么是视图)
    - [视图有哪些特点？](#视图有哪些特点)
    - [视图的使用场景有哪些？](#视图的使用场景有哪些)
    - [视图的优点](#视图的优点)
    - [视图的缺点](#视图的缺点)
    - [什么是游标？](#什么是游标)
    - [什么是存储过程？有哪些优缺点？](#什么是存储过程有哪些优缺点)
    - [什么是触发器？触发器的使用场景有哪些？](#什么是触发器触发器的使用场景有哪些)
    - [MySQL中都有哪些触发器？](#mysql中都有哪些触发器)
    - [SQL语句主要分为哪几类](#sql语句主要分为哪几类)
    - [超键、候选键、主键、外键分别是什么？](#超键候选键主键外键分别是什么)
    - [SQL约束有哪几种？](#sql约束有哪几种)
    - [六种关联查询](#六种关联查询)
    - [什么是子查询](#什么是子查询)
    - [子查询的三种情况](#子查询的三种情况)
    - [mysql中in和exists区别](#mysql中in和exists区别)
    - [varchar与char的区别](#varchar与char的区别)
    - [varchar(50)中50的涵义](#varchar50中50的涵义)
    - [int(20)中20的涵义](#int20中20的涵义)
    - [mysql中int(10)和char(10)以及varchar(10)的区别](#mysql中int10和char10以及varchar10的区别)
    - [FLOAT和DOUBLE的区别是什么？](#float和double的区别是什么)
    - [drop、delete与truncate的区别](#dropdelete与truncate的区别)
    - [UNION与UNIONALL的区别？](#union与unionall的区别)
    - [创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？](#创建的索引有没有被使用到或者说怎么才可以知道这条语句运行很慢的原因)
    - [执行计划包含信息](#执行计划包含信息)
    - [SQL性能优化的目标：](#sql性能优化的目标)
    - [SQL的生命周期？](#sql的生命周期)
    - [大表数据查询，怎么优化](#大表数据查询怎么优化)
    - [超大分页怎么处理？](#超大分页怎么处理)
    - [mysql分页](#mysql分页)
    - [慢查询日志](#慢查询日志)
    - [慢查询都怎么优化过？](#慢查询都怎么优化过)
    - [为什么要尽量设定一个主键？](#为什么要尽量设定一个主键)
    - [主键使用自增ID还是UUID？](#主键使用自增id还是uuid)
    - [innodb没有设置主键聚簇索引是](#innodb没有设置主键聚簇索引是)
    - [字段为什么要求定义为not null？](#字段为什么要求定义为not-null)
    - [如果要存储用户的密码散列，应该使用什么字段进行存储？](#如果要存储用户的密码散列应该使用什么字段进行存储)
    - [优化查询过程中的数据访问](#优化查询过程中的数据访问)
    - [优化长难的查询语句](#优化长难的查询语句)
    - [优化特定类型的查询语句](#优化特定类型的查询语句)
    - [mysql锁的概念](#mysql锁的概念)
    - [解决死锁状态的两种方法](#解决死锁状态的两种方法)
    - [产生死锁的四个必要条件](#产生死锁的四个必要条件)
    - [最大限度地降低死锁的方法](#最大限度地降低死锁的方法)
    - [Spring 事务四种实现方式：](#spring-事务四种实现方式)
    - [编程式事务和声明式事务的区别](#编程式事务和声明式事务的区别)
    - [如何实现编程式事务？](#如何实现编程式事务)
    - [红黑树的实现原理和应用场景；](#红黑树的实现原理和应用场景)
    - [红黑树应用场景：](#红黑树应用场景)
    - [myisam和innodb两者的区别：](#myisam和innodb两者的区别)
    - [全文索引](#全文索引)
    - [MyISAM和InnoDB两者的应用场景：](#myisam和innodb两者的应用场景)
    - [Mysql怎么分表，以及分表后如果想按条件分页查询怎么办](#mysql怎么分表以及分表后如果想按条件分页查询怎么办)
    - [mysql 数据库 分表后 怎么进行分页查询？Mysql分库分表方案?](#mysql-数据库-分表后-怎么进行分页查询mysql分库分表方案)
    - [分表方案](#分表方案)
    - [merge引擎](#merge引擎)
    - [limit语句特点](#limit语句特点)
    - [分页问题](#分页问题)
    - [理解分布式id生成算法SnowFlake](#理解分布式id生成算法snowflake)
    - [Mysql主从同步的实现原理](#mysql主从同步的实现原理)
    - [mysql主从同步](#mysql主从同步)
    - [主从同步有什么好处？](#主从同步有什么好处)
    - [主从同步事件：](#主从同步事件)
    - [binlog dump线程](#binlog-dump线程)
    - [在slave上的操作](#在slave上的操作)
    - [索引使用策略及优化](#索引使用策略及优化)
    - [mysql中的mvvc（多版本并发控制）](#mysql中的mvvc多版本并发控制)
    - [innodb](#innodb)
    - [关系型和非关系型数据库区别](#关系型和非关系型数据库区别)
# 数据库面试

## 基础知识

###


### 数据保存在内存
优点：存取速度快
缺点：数据不能永久保存
### 数据保存在文件
优点：数据永久保存
缺点：1）速度比内存操作慢，频繁的IO操作。
### 数据保存在数据库
1）数据永久保存
2）使用SQL语句，查询方便效率高。
3）管理数据方便
### 什么是SQL？
结构化查询语言(StructuredQueryLanguage)简称SQL，是一种数据库查询语言。
作用：用于存取数据、查询、更新和管理关系数据库系统。
### 什么是MySQL?
MySQL是一个关系型数据库管理系统

### 数据库三大范式是什么
    第一范式：每个列都不可以再拆分。
    第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
    第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
    在设计数据库结构的时候，要尽量遵守三范式，

### mysql有关权限的表都有哪几个

    mysql通过权限表来控制用户对数据库的访问,权限表存放在mysql数据库里,由
    mysql_install_db脚本初始化

    user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
    db权限表：记录各个帐号在各个数据库上的操作权限。
    table_priv权限表：记录数据表级的操作权限。
    columns_priv权限表：记录数据列级的操作权限。
    host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。

### MySQL的binlog有有几种录入格式？分别有什么区别？     
    有三种格式，statement，row和mixed。

    statement模式下，每一条会修改数据的sql都会记录在binlog中，不需要记录每一行的变化，减少
    了binlog日志量，节约了IO，提高性能,由于sql的执行是有上下文的，因此在保存的时候需要保存
    相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。

    row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，
    基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如altertable)，因此这种模式的
    文件保存的信息太多，日志量太大

    新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行
    记录。

    mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
    
### 数据库类型

    使用策略：
    对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。
    对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
    使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查
    询时会使用临时表，导致严重的性能开销。
    
    枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符
    串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是
    整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数
    日期和时间类型，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。
    如果需要存储微妙，可以使用bigint存储。

### MySQL存储引擎MyISAM与InnoDB区别

### 存储引擎

    存储引擎Storageengine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。

### 常用数据库引擎

    Innodb引擎：MyIASM引擎(原本Mysql的默认引擎，MEMORY引擎

     Innodb引擎：（如今mysql的默认引擎）提供事务的支持，提供了行级锁和外键的约束，设计的目标就是处理大数据容量的数据库系统
     MyIASM引擎(原本Mysql的默认引擎，不提供事务的支持，也不支持行级锁和外键。
     MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。
### MyISAM索引与InnoDB索引的区别？

    InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引
    InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效
    MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
    InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效
    
### 聚簇索引和非聚簇索引

    聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
    非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。

### InnoDB引擎的4大特性

    插入缓冲（insertbuffer)
    二次写(doublewrite)
    自适应哈希索引(ahi)
    预读(readahead

### 引擎的选择

    如果没有特别的需求，使用默认的Innodb即可。
    MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。
    Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，
    支持事务和外键。比如OA自动化办公系统。

### 索引

### 什么是索引？ 
    索引是一种特殊的文件，包含着对数据表里所有记录的引用指针。
    索引是一种数据结构，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树

### 索引的优缺点

    二、索引的优点
    1、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 

    2、可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 

    3、可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 

    4、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 

    5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

    三、索引的缺点
    1、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 

    2、索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 

    3、当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 索引有哪几种类型？

    主键索引:数据列不允许重复，不允许为NULL，一个表只能有一个主键。

    唯一索引:数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。

    普通索引:基本的索引类型，没有唯一性的限制，允许为NULL值。

    全文索引：是目前搜索引擎使用的一种关键技术。

### 索引的数据结构（b树，hash）

    InnoDB存储引擎的默认索引实现为：B+树索引
    哈希索引来说，底层的数据结构就是哈希表
    单条记录查询的时候，可以选择哈希索引，查询性能快；其余大部分场景，建议选择BTree索引。

    InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。

### 查询方式：

    主键索引区:PI(关联保存的时数据的地址)按主键查询,
    普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度快

### B+tree性质：

    1.n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
    2.叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依
    关键字的大小自小而大顺序链接
    3.所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字
    4.B+树中，数据对象的插入和删除仅在叶节点上进行。
    5.B+树有2个头指针，一个是树的根节点，一个是小关键码的叶节点

### hash索引


    hash表+链表
    主要就是通过Hash算法将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞，则在对应Hash键下以链表形式存储。

### 索引的基本原理

    1. 把创建了索引的列的内容进行排序
    2. 对排序结果生成倒排表
    3. 在倒排表内容上拼上数据地址链
    4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

### 两种索引算法的区别：

    BTree是常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和
    between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的
    常量

    HashHash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索
    引需要从根节点到枝节点，后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

### 创建索引的原则

    1）左前缀匹配原则，组合索引非常重要的原则
    2）较频繁作为查询条件的字段才去创建索引
    3）更新频繁字段不适合创建索引
    4）若是不能有效区分数据的列不适合做索引列
    5）尽量的扩展索引，不要新建索引。
    6）定义有外键的数据列一定要建立索引。
    7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
    8）对于定义为text、image和bit的数据类型的列不要建立索引

### 创建索引的三种方式

    第一种方式：在执行CREATETABLE时创建索引
    第二种方式：使用ALTERTABLE命令去增加索引
    第三种方式：使用CREATEINDEX命令创建

### 使用索引查询一定能提高查询的性能吗？为什么

    通常，通过索引查询数据比全表扫描要快。
    索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。

### 索引范围查询(INDEXRANGESCAN)适用于两种情况:
    
    基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
    基于非唯一性索引的检索

### 百万级别或以上的数据如何删除

    1. 可以先删除索引
    2. 然后删除其中无用数据
    3. 删除完成后重新创建索引

### 前缀索引

    语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。
    前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。

### 什么是最左前缀原则？什么是最左匹配原则

    最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

    最左前缀匹配原则：mysql会一直向右匹配直到遇到范围查询

### B树和B+树的区别  

    B树 键和值存放在内部节点和叶子节点；
    B+树 内部节点都是键，没有值，叶子节点同时存放键和值
    B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。

### 使用B树的好处

    B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。


### 使用B+树的好处

    B+树的内部节点只存放键，不存放值
    一次读取，可以在内存页中获取更多的键，有利于更
    快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需
    要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每
    一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

### hash索引和B+树有什么区别或者说优劣呢

    1.底层原理

        hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。

        B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。

    2.hash索引进行等值查询更快(一般情况下)，引不支持使用索引进行排序，但是却无法进行范围查询。hash索引不支持模糊查询以及多列索引的最左前缀匹配。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

    3.hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。

    4.hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

### B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据

    在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是非聚簇索引和聚簇索引。

    在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引

    当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询

### 辅助索引

    innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

### 何时使用聚簇索引与非聚簇索引
![](\img\Snipaste_2022-10-15_10-54-42.png)

### 非聚簇索引一定会回表查询吗？

    不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询
    举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employeewhere age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

### 联合索引是什么？为什么需要注意联合索引中的顺序？

    MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

### 数据库事务

    事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

### 事物的四大特性(ACID)介绍一下?

    原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作
    要么全部完成，要么完全不起作用；
    2. 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的，并且没有破坏表的结构；
    3. 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    4. 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 什么是脏读？幻读？不可重复读？

### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？

### 隔离级别与锁的关系

    在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突
    在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；
    在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须
    等待事务执行完毕以后才释放共享锁。
    SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

### 按照锁的粒度分数据库锁有哪些？

    在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

### MyISAM和InnoDB存储引擎使用的锁：
    MyISAM采用表级锁(table-level locking)。
    InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

### 行级锁，表级锁和页级锁对比

    行级锁 行级锁是Mysql中锁定粒度最细的一种锁，行级锁分为共享锁 和 排他锁。

    特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

    表级锁 表级锁是MySQL中锁定粒度最大的一种锁
    表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

    特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

    页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁

    表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

    特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

### MySQL中InnoDB引擎的行锁是怎么实现的？

    InnoDB是基于索引来完成行锁

### InnoDB存储引擎的锁的算法有三种

    Record lock：单个行记录上的锁
    Gap lock：间隙锁，锁定一个范围，不包括记录本身
    Next-key lock：record+gap 锁定一个范围，包含记录本身

### 什么是死锁？怎么解决？

    死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

    常见的解决死锁的方法
    1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表
    2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，
    3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

###  为什么要使用视图？什么是视图？ 
    
    为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性

    本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。

### 视图有哪些特点？

    视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
    视图是由基本表(实表)产生的表(虚表)。
    视图的建立和删除不影响基本表。
    对视图内容的更新(添加，删除和修改)直接影响基本表。
    当视图来自多个基本表时，不允许添加和删除数据。视图的操作包括创建视图，查看视图，删除视
    图和修改视图。

### 视图的使用场景有哪些？

    简化sql查询，提高开发效率，是兼容老的表结构。
    重用SQL语句；
    简化复杂的SQL操作
    保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
    更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据

### 视图的优点

    1. 查询简单化。视图能简化用户的操作
    2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护逻辑数据独立性

### 视图的缺点

    1. 性能。数据库必须把视图的查询转化成对基本表的查询
    2. 修改限制。对于比较复杂的视图，可能是不可修改

        特征：
        1. 有UNIQUE等集合操作符的视图。
        2.有GROUP BY子句的视图。
        3.有诸如AVG\SUM\MAX等聚合函数的视图。
        4.使用DISTINCT关键字的视图。
        5.连接表的视图（其中有些例外）

### 什么是游标？

    游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理

### 什么是存储过程？有哪些优缺点？

    存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。

    优点:
    1） 存储过程是预编译过的，执行效率高。
    2） 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
    3） 安全性高，执行存储过程需要有一定权限的用户。
    4） 存储过程可以重复使用，减少数据库开发人员的工作量。
    缺点:
    1） 调试麻烦，
    2） 移植问题
    3） 重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译
    4） 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了， 后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。

### 什么是触发器？触发器的使用场景有哪些？

    触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。

### MySQL中都有哪些触发器？

    Before Insert
    After Insert
    Before Update
    After Update
    Before Delete
    After Delete

### SQL语句主要分为哪几类

    数据定义语言DDL CREATE，DROP，ALTER
    数据查询语言DQL（Data Query Language）SELECT
    数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE
    数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK

### 超键、候选键、主键、外键分别是什么？

    超键：在关系中能唯一标识元组的属性
        一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
        候选键：是 小超键，即没有冗余元素的超键。
        主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。
        一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
    外键：在一个表中存在的另一个表的主键称此表的外键。

### SQL约束有哪几种？

    NOT NULL: 用于控制字段的内容一定不能为空
    UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
    PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个
    FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。

### 六种关联查询


    交叉连接
    内连接
    外连接
    联合查询
    全连接
    

    内连接可分为 等值连接，不等值连接，自连接
    外连接：左外连接，右外连接，
    全连接：mysql不支持全连接，使用left join 和 union 和right join 联合使用

### 什么是子查询

    1. 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果
    2. 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。

### 子查询的三种情况

    1.子查询是单行单列的情况：结果集是一个值，父查询使用：=、 <、 > 等运算符
    2. 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符
    3. 3. 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where 条件，用于select子句中做为子表

### mysql中in和exists区别

    mysql中的in语句是把外表和内表作hash 连接，
    而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。

    分别适用的情景：
        1. 如果查询的两个表大小相当，那么用in和exists差别不大。
        2. 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。
        3. not in 和not exists：
            如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引
            not extsts的子查询依然能用到表上的索引
            无论那个表大，用not exists都比not in要快。

### varchar与char的区别

    char表示定长字符串，长度是固定的，插入数据的长度小于char的固定长度时，则用空格填充
    长度固定，所以存取速度要比varchar快很多
    正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；

    varchar表示可变长字符串，长度是可变的；
    插入的数据是多长，就按照多长来存储
    存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；

### varchar(50)中50的涵义

    多存放50个字符，varchar（50）和（200）存储相同自负床所占空间是一样的，后者在排序时会消耗更多内存
    order by col采用fixed_length计算col长度
    早期 MySQL 版本中， 50 代表字节数，现在代表字符数。

### int(20)中20的涵义

    显示字符的长度，20表示 大显示宽度为20，但仍占4字节存储，存储范围不变；不影响内部存储

### mysql中int(10)和char(10)以及varchar(10)的区别

    int(10)的10表示显示的数据的长度，不是存储数据的大小； chart(10)和varchar(10)的10表示存储
    数据的大小，即表示存储多少个字符。

    char(10) 10位固定字符串，不足补空格 最多10个字符
    varchar(10) 10位可变字符串，不足补空格 多10个字符
    空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符

### FLOAT和DOUBLE的区别是什么？

    float存储至多8位十进制数，并在内存中占4字节。
    double 存储至多18位十进制数，并在内存中占8字节。

### drop、delete与truncate的区别

![](img\Snipaste_2022-10-15_14-21-08.png)  
    在不再需要一张表的时候，用drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用truncate。

### UNION与UNIONALL的区别？

    UNION ALL，不会合并重复的记录行
    效率 UNION 高于 UNION ALL

### 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？

    低性能的SQL语句的定位,是使用执行计划,MySQL提供了explain查看语句的执行计划

    explain使用方法 在查询语句之前加入 explain

    执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息

### 执行计划包含信息

    信息id ，一组数字组成，表示一个查询中各个子查询的执行顺序;
    id相同执行顺序由上至下。
    id不同，id值越大优先级越高，越先被执行。
    id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。

    select_type
    type 核心属性：分为
        system > const > eq_ref > ref > range > index > ALL

        system（无法重现）
        const where条件是主键
        eq-ref 无法重现 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联
        ref 查询普通索引（非唯一索引）
        range 有范围的索引扫描
        index 只遍历索引树
        all 全表扫描

    extra 的信息
        1. Using index 使用覆盖索引
       1. Using where 使用了用where子句来过滤结果集
       2. Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。
       3. Using temporary 使用了临时表
   
### SQL性能优化的目标：

    至少要达到 range 级别，要求是ref级别，如果可以是consts 好

### SQL的生命周期？

    1. 应用服务器与数据库服务器建立一个连接
    2. 数据库进程拿到请求sql
    3. 解析并生成执行计划，执行
    4. 读取数据到内存并进行逻辑处理
    5. 通过步骤一的连接，发送结果到客户端
    6. 关掉连接，释放资源

### 大表数据查询，怎么优化

    1. 优化shema、sql语句+索引；
    2. 第二加缓存，memcached, redis；
    3. 主从复制，读写分离；
    4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；
    5. 水平切分，针对数据量大的表，选择合理的sharing key sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；

### 超大分页怎么处理？

    分两个方向进行解决
        数据库层面

            select * from table where age> 20 limit 1000000,10
            可以修改为select * from table where id in(select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快
        从需求的角度减少这种请求…主要是不做类似的需求，只允许逐页查看或者按照给定的路线走,这样可预测,可缓存

### mysql分页

    LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数

    LIMIT 接受一个或两个数字参数。参数必须是一个整数常量
    第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的 大数目。初始记录行的偏移量是 0(而不是 1)

        了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为-1：

### 慢查询日志

    用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。

    语法：
    查看慢日志是否开启
        SHOW VARIABLES LIKE 'slow_query%';
    开启慢日志
        set GLOBAL slow_query_log = on来开启
        在datadir下产生一个xxx-slow.log的文件。

    查看临界时间：
        SHOW VARIABLES LIKE 'long_query_time';
        单位秒设置：set long_query_time=0.5

        查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中

### 慢查询都怎么优化过？

    在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是 load了不需要的数据列？还是数据量太大？所以优化也是针对这三个方向来的，

    首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

    分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。

    如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表

### 为什么要尽量设定一个主键？

    主键是数据库确保数据行在整张表唯一性的保障
    设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。

### 主键使用自增ID还是UUID？

    推荐使用自增ID，不要使用UUID
    在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，
    如果主键索引是自增ID，那么只需要不断向后排列即可，
    如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。

### innodb没有设置主键聚簇索引是

    主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。

### 字段为什么要求定义为not null？

    null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。

### 如果要存储用户的密码散列，应该使用什么字段进行存储？

    密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar 来存储，这样可以节省空间且提高检索效率。

### 优化查询过程中的数据访问

    访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据

    查询不需要的数据。解决办法：使用limit解决
    多表关联返回全部列。解决办法：指定列名
    总是返回全部列。
        解决办法：避免使用SELECT * 重复查询相同的数据
        解决办法：可以缓存数据，下次直接读取缓存是否在扫描额外的记录。
        解决办法：使用explain进行分析
            发现查询需要扫描大量的数据，但只返回少数的行，

            使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
            改变数据库和表的结构，修改数据表范式
            重写SQL语句，让优化器可以以更优的方式执行查询。

### 优化长难的查询语句

    切分查询将一个大的查询分为多个小的相同的查询
    好处：
        分解关联查询，让缓存的效率更高。
        执行单个查询可以减少锁的竞争。
        在应用层做关联更容易对数据库进行拆分。
        查询效率会有大幅提升。
        较少冗余记录的查询

### 优化特定类型的查询语句

     count()会忽略所有的列，直接统计所有列数，不要使用count(列名) 
     可以使用explain查询近似值，用近似值替代count(*) 增加汇总表使用缓存

### mysql锁的概念

    乐观锁

    悲观锁
        在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中synchronized很 相似，共享锁（读锁）和排它锁（写锁）是悲观锁的不同的实现

    共享锁（读锁）
        所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前 其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了
    排他锁（写锁）
        若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务 不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。

    表级锁

        innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的
    行级锁

        行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级 锁。

### 解决死锁状态的两种方法

    第一种：
        1.查询是否锁表
            show OPEN TABLES where In_use > 0;
        2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）
            show processlist
        3.杀死进程id（就是上面命令的id列）
            kill id
    第二种：
    1.查看当前的事务
        SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
    2.查看当前锁定的事务
        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
    3.查看当前等锁的事务    
        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
   
### 产生死锁的四个必要条件

    （1） 互斥条件：一个资源每次只能被一个进程使用。
    （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
    （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 最大限度地降低死锁的方法

    （1）按同一顺序访问对象。
    （2）避免事务中的用户交互。
    （3）保持事务简短并在一个批处理中。
    （4）使用低隔离级别。
    （5）使用绑定连接。

### Spring 事务四种实现方式：

    基于编程式事务管理实现
    基于TransactionProxyFactoryBean的声明式事务管理
    基于AspectJ的XML声明式事务管理
    基于注解的声明式事务管理

### 编程式事务和声明式事务的区别

    Spring提供了对编程式事务和声明式事务的支持，
    编程式事务允许用户在代码中精确定义事务的边界，
    而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦

    编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；
    而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现

### 如何实现编程式事务？

    Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager。

### 红黑树的实现原理和应用场景；
    红黑树(一棵自平衡的排序二叉树)五大特性：
        1）每个结点要么是红的，要么是黑的。 
        2）根结点是黑的。 
        3）每个叶结点，即空结点是黑的。 
        4）如果一个结点是红的，那么它的俩个儿子都是黑的。 
        5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。

### 红黑树应用场景：

    1）广泛用于C++的STL中,map和set都是用红黑树实现的
    2）著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存 区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址 虚拟存储区域,右指针指向相邻的高地址虚拟地址空间
    3）IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
    4）ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
    5）java中的TreeSet,TreeMap

### myisam和innodb两者的区别：

    1.事务支持：
    2.存储结构：
        MyISAM：每个MyISAM在磁盘上存储成三个文件。
        三个文件分别为
        第一表以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI(MYIndex)。
        Innodb：所有的表都保存在同一个数据文件中，大小只受限于操作系统文件的大小，一般为2GB。
    3. 存储空间
    MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能
    有空格，会被去掉)、动态表、压缩表。
    InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
    4.可移植性、备份及恢复
    MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针
    对某个表进行操作。
    InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的
    时候就相对痛苦了。
    5.AUTO_INCREMENT
    MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动
    增长可以不是第一列
    InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必
    须是组合索引的第一列。
    6.表锁差异
    MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自
    动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
    InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是
    InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
    7.全文索引
    MyISAM：支持(FULLTEXT类型的)全文索引
    InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效
    果更好。
    8.表主键
    MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
    InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是
    主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。
    10) 表的具体行数
    MyISAM：保存有表的总行数，如果select count() from table;会直接取出出该值。
    InnoDB：没有保存表的总行数(只能遍历)，如果使用select count() from table；就会遍历整个表，消耗
    相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
    11) CURD操作
    MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。
    InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。
    DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，
    在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。
    12) 外键
    MyISAM：不支持
    InnoDB：支持
    13) 查询效率
    没有where的count()使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count()时它直接
    从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count()时一般要伴随where，且where中
    要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data
    存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count()的话
    使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。
    MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
    通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的
    特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯
    定要比MyISAM强很多。另



### 全文索引

    全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。

### MyISAM和InnoDB两者的应用场景：

  1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的
  SELECT查询，那么MyISAM是更好的选择。
  2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的
  INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

  在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。
    大尺寸倾向于innodb，因为事务日志，故障恢复。

### Mysql怎么分表，以及分表后如果想按条件分页查询怎么办

    如果按时间排序查询，使用limit n （不要使用limit m, n 页数多了之后效率低）然后记录最后一条的时间，下次从最后一条的时间开始查询

### mysql 数据库 分表后 怎么进行分页查询？Mysql分库分表方案?

    1.如果只是为了分页，可以考虑这种分表，就是表的id是范围性的，且id是连续的，比如第一张表id是1
    到10万，第二张是10万到20万，这样分页应该没什么问题。
    2.如果是其他的分表方式，建议用sphinx先建索引，然后查询分页，我们公司现在就是这样干的

### 分表方案

    1.mysql proxy：amoeba

    做mysql集群,利用amoeba。
    从上层的java程序来讲，不需要知道主服务器和从服务器的来源，即主从数据库服务器对于上层来讲是
    透明的。可以通过amoeba来配置。
    3.大数据量并且访问频繁的表，将其分为若干个表

    比如对于某网站平台的数据库表-公司表，数据量很大，这种能预估出来的大数据量表，我们就事先分出
    个N个表，这个N是多少，根据实际情况而定。

    4.利用merge存储引擎来实现分表

### merge引擎

    merge 存储引擎也被称为MGR_MyISAM 存储引擎，它实际上是将一组Myisam 表聚合在一起。使用时就像一张表
    merge 存储引擎所有的表必须拥有相同的表结构

### limit语句特点

    1）limit语句的查询时间与起始记录的位置成正比
    2）mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。

### 分页问题 

    mysql大数据量使用limit分页，随着页码的增大，查询效率越低下

### 理解分布式id生成算法SnowFlake

    snowflake
        1位 ，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0
        41位 ，用来记录时间戳（毫秒）
        10位 ，用来记录工作机器id。
        12位 ，序列号，用来记录同毫秒内产生的不同id。
    
    由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的

    SnowFlake可以保证：
        所有生成的id按时间趋势递增
        整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）

### Mysql主从同步的实现原理

    在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。

### mysql主从同步

    当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。

### 主从同步有什么好处？

    水平扩展数据库的负载能力。
    容错，高可用。Failover(失败切换)/High Availability
    数据备份。

### 主从同步事件：

    在master机器上，主从同步事件会被写到特殊的log文件种（binary-log）
    主从同步事件：
        三种形式：
            statement，row，mixed
           1. statement：会将对数据库操作的sql语句写入到binlog中。
           2. row：会将每一条数据的变化写入到binlog中。
           3. mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式
           的binlog

### binlog dump线程

    当slave连接到master的时候，master机器会为slave开启binlog dump线程。当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。

### 在slave上的操作

    当主从同步时，slave上会创建2个线程
        I/O线程：该线程连接到master机器，master机器上的binlog dump线程会将binlog的内容发送给io线程，io线程在收到binlog内容后，再将内容写入本地的relay log
        sql线程：该线程读取io线程写入的relay log 并且根据relay log 的内容队slave数据库做相应的操作

### 索引使用策略及优化

    主要分为结构优化和查询优化

### mysql中的mvvc（多版本并发控制）

    在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：
        6字节的事务ID（ DB_TRX_ID ）
        7字节的回滚指针（DB_ROLL_PTR）
        隐藏的ID

### innodb
    而Innodb的
        实现方式是：
        事务以排他锁的形式修改原始数据
        把修改前的数据存放于undo log，通过回滚指针与主数据关联
        修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）

### 关系型和非关系型数据库区别

    关系型数据库：是指采用了关系模型(二维表格模型)来组织数据的数据库。
    非关系型数据库：以键值对存储，且结构不固定


