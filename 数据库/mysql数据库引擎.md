# Mysql数据库概述

    MySQL数据库是一个单进程多线程模型的数据库。

    数据库实例就是进程加内存的组合

## mysql常用引擎

    Innodb、Myisam、Memory

### Innodb和myisam的区别

    MyISAM：不支持事务，页级锁，并发能力差

    InnDB（从mysql-5.5.5开始作为默认存储引擎）：支持事务，行级锁，并发性能相对较强

## 数据库引擎MyIsam

    在执行 SELECT 前，会自动给涉及的所有表加读锁。

    在执行 UPDATE、DELETE、INSERT 前，会自动给涉及的表加写锁。

    MyIsam中写锁和读锁是相互排斥的

    MyISAM 存储引擎下读锁和写锁是互斥的，当两个请求同时到达的情况下，一个申请写锁，一个申请读锁，MyISAM 存储引擎只能设置写锁或者读锁，不能同时设置两个锁。

    MyISAM存储引擎下写锁的优先级比较高

    默认情况下，同一时间点上，同时到达两个进程，分别申请读锁和写锁的情况，Mysql 会优先给写锁。如果读请求先到锁等待队列里面排队，写请求后到锁等待队列的话，也是优先给写锁。默认情况，Mysql 认为写比读更重要。

## 数据库引擎InnoDB

### Innodb体系结构：

        由内存结构、线程、磁盘文件组成

### Innodb

    innodb必须有主键，并且推荐使用整型的自增主键
    B+树，整型是因为B+树需要比较大小，整型比字符串快，占用字节小，节约磁盘空间。自增是因为UUID这种会导致树的分裂，平衡，自增的会往后顺序增

### innodb存储结构

    innodb逻辑存储结构主要分为表空间，段，区和页，
    层级关系：
        tablespace-----》segment-----》extent-----》page
    
    表空间又分为独立表空间和系统表空间
        mysql默认使用独立表空间

### Innodb常识：

    在InnoDB下，加锁之前，为什么需要先 start transaction？

    InnoDB 锁的释放在事务提交/回滚之后，事务一旦提交/回滚之后，就会自动释放事务中的锁。

    InnoDB 默认情况下 autocommit=1 即开启自动提交，在自动提交模式下，每执行一句 sql，就自动提交事务，锁也会立即释放。这种情况下无法手动控制事务的提交以及锁的释放时间。

    因此，在进行锁的相关操作之前，先 start transaction（关闭自动提交模式，开启手动提交模式），这样事务中的每一 sql 执行完成，锁一直不会释放，直到我们手动提交事务，锁才会释放。

    检索条件使用索引和不使用索引的锁区别？

    检索条件有索引的情况会锁定特定的一些行。

    检索条件没有使用索引的情况下会进行全表扫描，从而锁定全部的行（包括不存在的记录）

    检索条件使用索引和不使用索引的锁区别？

    InnoDB引擎加锁原则，遵循二段锁协议，即上锁分为两个阶段，事务开始后进入加锁阶段，事务 commit 或 rollback 进入解锁阶段，这样可以在并发事务的时候串行化处理。

    InnoDB 下的锁？

    相比于MyISAM引擎，InnoDB下锁的种类更为多样和复杂，大概有如下几种锁：

    共享锁、排他锁、意向共享锁、意向排他锁
    记录锁、间隙锁、next-key锁
    悲观锁、乐观锁

### Innodb的结构：
    页头、页目录、数据区

    页头：包含前后页的指针
    页目录：包含数据区（分组）的最小id值，方便通过指针查询到数据
    数据区：用于存放数据，指针依次向下。

    为什么要引入页目录？

    比如：我要查询id为4的数据，需要从上到下查询4次。把数据区的数据分组，页目录存储每组数据最小的id值。那么我只需要通过目录3，查询2次即可。提高了查询效率。
![页目录的作用](img\引入页目录的作用：.png)

