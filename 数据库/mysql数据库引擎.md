# Mysql数据库概述

    MySQL数据库是一个单进程多线程模型的数据库。

    数据库实例就是进程加内存的组合

## mysql常用引擎

    Innodb、（行级锁）Myisam、Memory、（表级锁）bdb引擎（页级锁）

### Innodb和myiam的区别

    MyISAM：不支持事务，页级锁，并发能力差

    InnDB（从mysql-5.5.5开始作为默认存储引擎）：支持事务，行级锁，并发性能相对较强

    BDB引擎： 页级锁

## 数据库引擎MyIsam

    在执行 SELECT 前，会自动给涉及的所有表加读锁。

    在执行 UPDATE、DELETE、INSERT 前，会自动给涉及的表加写锁。

    MyIsam中写锁和读锁是相互排斥的

    MyISAM 存储引擎下读锁和写锁是互斥的，当两个请求同时到达的情况下，一个申请写锁，一个申请读锁，MyISAM 存储引擎只能设置写锁或者读锁，不能同时设置两个锁。

    MyISAM存储引擎下写锁的优先级比较高

    默认情况下，同一时间点上，同时到达两个进程，分别申请读锁和写锁的情况，Mysql 会优先给写锁。如果读请求先到锁等待队列里面排队，写请求后到锁等待队列的话，也是优先给写锁。默认情况，Mysql 认为写比读更重要。

## 数据库引擎InnoDB

### Innodb体系结构：

        由内存结构、线程、磁盘文件组成

### Innodb

    innodb必须有主键，并且推荐使用整型的自增主键
    B+树，整型是因为B+树需要比较大小，整型比字符串快，占用字节小，节约磁盘空间。自增是因为UUID这种会导致树的分裂，平衡，自增的会往后顺序增

### innodb存储结构

    innodb逻辑存储结构主要分为表空间，段，区和页，
    层级关系：
        tablespace-----》segment-----》extent-----》page
    
    表空间又分为独立表空间和系统表空间
        mysql默认使用独立表空间

### Innodb常识：

    在InnoDB下，加锁之前，为什么需要先 start transaction？

    InnoDB 锁的释放在事务提交/回滚之后，事务一旦提交/回滚之后，就会自动释放事务中的锁。

    InnoDB 默认情况下 autocommit=1 即开启自动提交，在自动提交模式下，每执行一句 sql，就自动提交事务，锁也会立即释放。这种情况下无法手动控制事务的提交以及锁的释放时间。

    因此，在进行锁的相关操作之前，先 start transaction（关闭自动提交模式，开启手动提交模式），这样事务中的每一 sql 执行完成，锁一直不会释放，直到我们手动提交事务，锁才会释放。

    检索条件使用索引和不使用索引的锁区别？

    检索条件有索引的情况会锁定特定的一些行。

    检索条件没有使用索引的情况下会进行全表扫描，从而锁定全部的行（包括不存在的记录）

    检索条件使用索引和不使用索引的锁区别？

    InnoDB引擎加锁原则，遵循二段锁协议，即上锁分为两个阶段，事务开始后进入加锁阶段，事务 commit 或 rollback 进入解锁阶段，这样可以在并发事务的时候串行化处理。

    InnoDB 下的锁？

    相比于MyISAM引擎，InnoDB下锁的种类更为多样和复杂，大概有如下几种锁：

    共享锁、排他锁、意向共享锁、意向排他锁
    记录锁、间隙锁、next-key锁
    悲观锁、乐观锁

### Innodb的结构：
    页头、页目录、数据区

    页头：包含前后页的指针
    页目录：包含数据区（分组）的最小id值，方便通过指针查询到数据
    数据区：用于存放数据，指针依次向下。

    为什么要引入页目录？

    比如：我要查询id为4的数据，需要从上到下查询4次。把数据区的数据分组，页目录存储每组数据最小的id值。那么我只需要通过目录3，查询2次即可。提高了查询效率。
![页目录的作用](img\引入页目录的作用：.png)

### Innodb没有设置主键的情况：

    Innodb中主键在该引擎中的作用：
        InnoDB按照每张表的主键构造一棵B+树，主键对应的索引就是聚簇索引，在每个叶子节点存放着数据表的行数据。所以主键对于InnoDB来说至关重要。
    
    InnoDB对聚簇索引的处理

        1、第一种情况：用户定义了主键，那么InnoDB会使用主键作为聚簇索引；

        2、第二种情况：用户没有定义主键，那么InnoDB会使用第一个非空的唯一索引作为聚簇索引；
        
        3、第三种情况：用户既没有定义主键，也没有定义唯一索引，那么InnoDB会自动生成一个不可见的ROW_ID的列名为GEN_CLUST_INDEX的聚簇索引，该列是一个6字节的自增数值，随着插入而自增。

    影响
        很明显，缺少主键的表，InnoDB会内置一列用于聚簇索引来组织数据。而没有建立主键的话就没法通过主键来进行索引，查询的时候都是全表扫描，小数据量没问题，大数据量就会出现性能问题。

        而且不设置主键不单单影响到查询，在进行写操作的时候，由于ROW_ID是共享的，这意味着插入的时候需要共享该序列，那么高并发插入的时候为了保持唯一性就避免不了锁的竞争，进而影响性能。

    总结
        由以上分析可以推论，在建表的时候无论如何都要设置主键，如何没有可用作主键的字段，可以设计一个业务无关的字段，比如xx_id。
    
## MyiSAM引擎
    二、MyISAM引擎适用场景
        由MyISAM的特性，我们就可以简单的列举MyISAM引擎适用场景了。
        1、不需要事务支持的场景。
        2、读取操作比较多，写入和修改操作比较少的场景。
        3、数据并发量较低的场景。
        4、硬件条件比较差的场景。
        5、在配置数据库读写分离场景下，MySQL从库可以使用MyISAM索引。